* [JAVA](#java)
	* [java学习疑问](#java学习疑问)
		* [1.什么是序列化和反序列化？](#1什么是序列化和反序列化)
		* [2.为什么成员变量没有多态？](#2为什么成员变量没有多态)
		* [3.泛型--协变和逆变？](#3泛型-协变和逆变)
		* [4.外部类和内部类成员间的相互访问规则?](#4外部类和内部类成员间的相互访问规则)
		* [5.为什么要有内部类?](#5为什么要有内部类)
		* [6.怎么使用内部类?](#6怎么使用内部类)
		* [7.流是什么？怎么使用？](#7流是什么怎么使用)
		* [8.接口中为什么只有常量，没有变量？](#8接口中为什么只有常量没有变量)
		* [9.接口中的常量为什么是public static final的？](#9接口中的常量为什么是public-static-final的)
		* [10.接口中的方法为什么是public static的？](#10接口中的方法为什么是public-static的)
		* [11.接口中的方法怎么调用？](#11接口中的方法怎么调用)
		* [12.静态属性和方法可以被继承吗？](#12静态属性和方法可以被继承吗)
		* [13.静态方法可以被重载吗？](#13静态方法可以被重载吗)
		* [14.静态方法可以被重写吗？](#14静态方法可以被重写吗)

# JAVA
## java学习疑问

### 1.什么是序列化和反序列化？

### 2.为什么成员变量没有多态？

### 3.泛型--协变和逆变？

### 4.外部类和内部类成员间的相互访问规则?

### 5.为什么要有内部类?

### 6.怎么使用内部类?

### 7.流是什么？怎么使用？

### 8.接口中为什么只有常量，没有变量？

### 9.接口中的常量为什么是public static final的？

### 10.接口中的方法为什么是public static的？

### 11.接口中的方法怎么调用？

### 12.静态属性和方法可以被继承吗？

* 子类只能从被扩展的父类获得成员变量、方法和内部类（包括内部接口、枚举），不能获得构造器和初始化块

* Java中所有方法都能被继承，包括私有方法(但不可见)和静态方法

``` java
/*
*静态方法可以被子类继承
*通过类名可以调用静态方法
*通过对象名调用静态方法（不建议使用此方法）
*/

/**
 * Class Animal is a superclass
 */
class Animal{
	public static void eat(){
		System.out.println("你猜我喜欢吃什么?");
	}
}

/**
 * Class Dog is the subclass of Animal
 */

public class Dog extends Animal{
	public static void main(String[] args){
		//Dog类继承的父类的eat静态方法
		//通过类名调用静态方法
		Dog.eat();	//你猜我喜欢吃什么?


		//通过对象调用静态方法（不建议用对象调用静态方法）
		Dog d = new Dog();
		d.eat();	//你猜我喜欢吃什么?
	}
}
```

### 13.静态方法可以被重载吗？

### 14.静态方法可以被重写吗？（从方法调用过程理解）

答案是：不可以。

子类包含与父类同名方法的现象被称为方法重写（Override），也被称为方法覆盖。可以说子类重写了父类的方法，也可以说子类覆盖了父类的方法。

> 覆盖方法和被覆盖方法要么都是类方法，要么都是实例方法，不能一个是类方法，一个是实例方法。

重写方法的目的是为了多态，或者说：重写是实现多态的前提，即重写是发生在继承中且是针对非static方法的。

首先明确一点，在子类中重写父类的static方法，是不会报错的，编译也可以通过，但是在通过一个声明为父类，实际类型为子类的引用变量调用该方法时，发现被调用的仍是父类中原本以为会被覆盖的方法，不具有“多态”特性。

语法上子类允许出现和父类只有方法体不一样其他都一模一样的static方法，但是在父类引用指向子类对象时，通过父类引用调用的依然是父类的static方法，而不是子类的static方法。





测试结果发现，ADHero h=new ADHero();h.battleWin();仍旧调用的是父类的battleWin方法，没有实现所谓的“多态”。

结论：父类的static方法是不会被重写的。

解释：在进行方法调用时，系统唯一的任务是确定被调用方法的版本。对于private、static、final方法或者构造器，这部分方法在程序真正运行之前就有一个可以确定的调用版本，并且该版本在运行期间是不可变的，编译器一开始就能确定要调用的版本，这叫做**静态绑定**，这些方法在类加载的时候就会把符号引用转化为该方法的直接引用。与之对应，在程序运行期间确定方法调用版本的调用方式叫做**动态绑定**，此时，虚拟机会为每个类创建一个方法表，列出所有方法签名和实际调用的方法，这样一来虚拟机在调用方法时，只用查找该表就行了，只有在调用时采用动态绑定的方法才能体现出多态特性。